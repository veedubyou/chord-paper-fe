{"version":3,"sources":["common/LyricTokenizer.ts","common/Collection.ts","common/ChordModel.ts","components/EditableLine.tsx","common/Whitespace.ts","components/ChordSymbol.tsx","components/Block.tsx","components/NonEditableLine.tsx","components/Line.tsx","components/ChordPaperBody.tsx","components/EditableTypography.tsx","components/Header.tsx","components/ChordPaperMenu.tsx","components/ChordPaper.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["tokenize","lineOfLyrics","matches","match","Collection","elements","this","undefined","id","index","findIndex","elem","Error","idable","indexOfBefore","indexOf","newElem","splice","stringifyIgnoreID","obj","JSON","stringify","key","value","ChordBlockValidator","iots","chord","lyric","type","ChordBlock","shortid","generate","splitIndex","tokens","lyricTokens","prevBlockLyricTokens","slice","thisBlockLyricTokens","prevBlock","join","validatedFields","jsonStr","result","parseJSON","isLeft","jsonObj","right","validationResult","decode","left","ChordLineValidator","ChordLine","newLyrics","lyrics","newChord","mergeBlocks","newPrevBlock","split","clone","chordBlocks","map","chordBlock","fromValidatedFields","SongMetadataValidator","title","composedBy","performedBy","asHeardFrom","ChordSongValidator","metadata","ChordSong","newTitle","newPerformedBy","newComposedBy","newAsHeardFrom","chordLineValidatedFields","lyricLines","lyricLine","fromLyrics","EditableLine","props","useState","children","setValue","inputRef","React","createRef","theme","useTheme","finish","newValue","onFinish","FilledInput","withStyles","variant","root","fontSize","typography","UnstyledFilledInput","autoFocus","inputProps","width","padding","style","browserInputProps","onBlur","onChange","event","target","onKeyDown","onPaste","payload","clipboardData","getData","linesOfText","length","onPasteOverflow","preventDefault","pasteContent","beforeSelectionStr","afterSelectionStr","current","selectionStart","selectionEnd","newPasteLines","composeMultilinePaste","fullWidth","data-testid","isWhitespace","s","test","inflateIfEmpty","ChordTypography","whiteSpace","color","palette","secondary","main","cursor","fontFamily","Typography","ChordSymbol","display","endsWith","formattedChord","WordTarget","SpaceTarget","backgroundColor","light","Block","editing","setEditing","chordRow","lyricBlocks","lyricToken","tokenIndex","typographyProps","onClick","onBlockSplit","lyricBlock","Box","onChordChange","Grid","container","direction","component","item","iconColorStyle","EditIcon","UnstyledEditIcon","AddIcon","UnstyledAddIcon","RemoveIcon","UnstyledRemoveIcon","Button","contained","primary","dark","UnstyledButton","Tooltip","tooltip","UnstyledTooltip","HighlightableBox","grey","maxWidth","spacing","NonEditableLine","chordLine","chordChangeHandler","setChord","onChangeLine","blockSplitHandler","splitBlock","blocks","placement","ButtonGroup","orientation","onEditButton","onAddButton","onRemoveButton","interactive","Line","removed","setRemoved","startEdit","finishEdit","replaceLyrics","addHandler","onAddLine","removeHandler","onRemoveLine","setTimeout","pasteOverflowHandler","overflowContent","editableLine","yeetDirection","Slide","in","timeout","borderBottom","borderColor","minWidth","margin","Paper","UnstyledPaper","ChordPaperBody","addLine","newLine","song","addAfter","notifySongChanged","removeLine","remove","changeLine","pasteOverflowFromLine","newChordLines","newLyricLine","onSongChanged","elevation","justify","chordLines","line","PlaceholderTypography","EditableTypography","onValueChange","placeholder","nonEditableLine","Header","leftHeader","xs","newHeardFrom","midHeader","align","rightHeader","newComposer","newPerformer","paddingTop","paddingLeft","paddingRight","SpeedDial","position","bottom","UnstyledSpeedDial","ChordPaperMenu","open","setOpen","enqueueSnackbar","useSnackbar","loadAction","a","inputElem","document","createElement","addEventListener","fileList","files","file","fileReader","FileReader","onload","ev","ArrayBuffer","results","deserialize","onLoad","readAsText","click","icon","SpeedDialIcon","onOpen","onClose","ariaLabel","SpeedDialAction","tooltipTitle","blob","Blob","serialize","objectURL","URL","createObjectURL","anchor","download","href","revokeObjectURL","RootPaper","minHeight","ChordPaper","initialSong","setSong","songChangeHandler","updatedSong","loadedSong","App","createMuiTheme","contrastText","fontWeightRegular","chords","assembleLine","arr","tokenSize","i","subArr","push","chunk","lyricChunk","Math","floor","random","ThemeProvider","assembleSong","Boolean","window","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7ce4e5c6.chunk.js","sourcesContent":["export const tokenize = (lineOfLyrics: string): string[] => {\n    const matches = lineOfLyrics.match(/((\\w|')+|[^\\w'])/g);\n    if (matches === null) {\n        return [];\n    }\n\n    return matches;\n};\n","// use the name of the class the ID is describing for T\n// e.g. IDable<\"Person\">\nexport interface IDable<T extends string> {\n    id: string;\n    type: T;\n}\n\nexport abstract class Collection<T extends IDable<U>, U extends string> {\n    elements: T[];\n\n    constructor(elements?: T[]) {\n        if (elements !== undefined) {\n            this.elements = elements; //TODO: consider whether this needs to be a shallow copy\n        } else {\n            this.elements = [];\n        }\n    }\n\n    protected indexOf(id: string): number {\n        const index = this.elements.findIndex((elem: T) => elem.id === id);\n\n        if (index < 0) {\n            throw new Error(\"Can't find element inside collection\");\n        }\n\n        return index;\n    }\n\n    abstract clone(): Collection<T, U>;\n\n    // adds a element after the specified id\n    addAfter(idable: IDable<U>, ...newElem: T[]): void {\n        const indexOfBefore = this.indexOf(idable.id);\n        this.elements.splice(indexOfBefore + 1, 0, ...newElem);\n    }\n\n    remove(idable: IDable<U>): T {\n        const index = this.indexOf(idable.id);\n        const removed = this.elements.splice(index, 1);\n        return removed[0];\n    }\n}\n","import { Collection, IDable } from \"./Collection\";\nimport shortid from \"shortid\";\nimport { tokenize } from \"./LyricTokenizer\";\nimport * as iots from \"io-ts\";\nimport { Either, right, left, isLeft, parseJSON } from \"fp-ts/lib/Either\";\n\ninterface ChordBlockConstructorParams {\n    chord: string;\n    lyric: string;\n}\n\nconst stringifyIgnoreID = (obj: unknown): string => {\n    return JSON.stringify(obj, (key: string, value: string) => {\n        if (key === \"id\") {\n            return undefined;\n        }\n\n        return value;\n    });\n};\n\nconst ChordBlockValidator = iots.type({\n    chord: iots.string,\n    lyric: iots.string,\n    type: iots.literal(\"ChordBlock\"),\n});\n\ntype ChordBlockValidatedFields = iots.TypeOf<typeof ChordBlockValidator>;\n\nexport class ChordBlock implements IDable<\"ChordBlock\"> {\n    id: string;\n    chord: string;\n    lyric: string;\n    type: \"ChordBlock\";\n\n    constructor({ chord, lyric }: ChordBlockConstructorParams) {\n        this.id = shortid.generate();\n        this.chord = chord;\n        this.lyric = lyric;\n        this.type = \"ChordBlock\";\n    }\n\n    serialize(): string {\n        return stringifyIgnoreID(this);\n    }\n\n    static fromValidatedFields(\n        validatedFields: ChordBlockValidatedFields\n    ): ChordBlock {\n        return new ChordBlock({\n            chord: validatedFields.chord,\n            lyric: validatedFields.lyric,\n        });\n    }\n\n    static deserialize(jsonStr: string): Either<Error, ChordBlock> {\n        const result: Either<Error, unknown> = parseJSON(\n            jsonStr,\n            () => new Error(\"Failed to parse json string\")\n        );\n\n        if (isLeft(result)) {\n            return result;\n        }\n\n        const jsonObj = result.right;\n        const validationResult = ChordBlockValidator.decode(jsonObj);\n\n        if (isLeft(validationResult)) {\n            return left(new Error(\"Invalid Chord Block object\"));\n        }\n\n        return right(\n            new ChordBlock({\n                chord: validationResult.right.chord,\n                lyric: validationResult.right.lyric,\n            })\n        );\n    }\n\n    get lyricTokens(): string[] {\n        return tokenize(this.lyric);\n    }\n\n    // splits a block, and returns the block before\n    // e.g.\n    // {id:\"A\", chord: \"B7\", lyric:\"my dear we're\"}\n    // splitBlock(4) =>\n    // {id:\"B\", chord: \"B7\", lyric:\"my dear \"}\n    // {id:\"A\", chord: \"\", \"we're\"}\n    split(splitIndex: number): ChordBlock {\n        if (splitIndex === 0) {\n            throw new Error(\"Split index can't be zero\");\n        }\n\n        const tokens = this.lyricTokens;\n        const prevBlockLyricTokens: string[] = tokens.slice(0, splitIndex);\n        const thisBlockLyricTokens: string[] = tokens.slice(splitIndex);\n\n        const prevBlock: ChordBlock = new ChordBlock({\n            chord: this.chord,\n            lyric: prevBlockLyricTokens.join(\"\"),\n        });\n\n        this.chord = \"\";\n        this.lyric = thisBlockLyricTokens.join(\"\");\n\n        return prevBlock;\n    }\n}\n\nconst ChordLineValidator = iots.type({\n    elements: iots.array(ChordBlockValidator),\n    type: iots.literal(\"ChordLine\"),\n});\ntype ChordLineValidatedFields = iots.TypeOf<typeof ChordLineValidator>;\n\nexport class ChordLine extends Collection<ChordBlock, \"ChordBlock\">\n    implements IDable<\"ChordLine\"> {\n    id: string;\n    type: \"ChordLine\";\n\n    constructor(elements?: ChordBlock[]) {\n        super(elements);\n\n        this.id = shortid.generate();\n        this.type = \"ChordLine\";\n    }\n\n    static fromValidatedFields(\n        validatedFields: ChordLineValidatedFields\n    ): ChordLine {\n        const chordBlockElems: ChordBlock[] = validatedFields.elements.map(\n            (value: ChordBlockValidatedFields) => {\n                return ChordBlock.fromValidatedFields(value);\n            }\n        );\n\n        return new ChordLine(chordBlockElems);\n    }\n\n    serialize(): string {\n        return stringifyIgnoreID(this);\n    }\n\n    static deserialize(jsonStr: string): Either<Error, ChordLine> {\n        const result: Either<Error, unknown> = parseJSON(\n            jsonStr,\n            () => new Error(\"Failed to parse json string\")\n        );\n\n        if (isLeft(result)) {\n            return result;\n        }\n\n        const jsonObj = result.right;\n        const validationResult = ChordLineValidator.decode(jsonObj);\n\n        if (isLeft(validationResult)) {\n            return left(new Error(\"Invalid Chord Line object\"));\n        }\n\n        return right(this.fromValidatedFields(validationResult.right));\n    }\n\n    static fromLyrics(lyrics: string): ChordLine {\n        const block = new ChordBlock({\n            chord: \"\",\n            lyric: lyrics,\n        });\n\n        return new ChordLine([block]);\n    }\n\n    get chordBlocks(): ChordBlock[] {\n        return this.elements;\n    }\n\n    get lyrics(): string {\n        const lyricTokens = this.chordBlocks.map(\n            (chordBlock: ChordBlock) => chordBlock.lyric\n        );\n\n        return lyricTokens.join(\"\");\n    }\n\n    replaceLyrics(newLyrics: string): void {\n        if (newLyrics === this.lyrics) {\n            return;\n        }\n\n        this.elements = [\n            new ChordBlock({\n                // TODO: feature next. chords are currently destructively wiped\n                // because anchoring information is lost between edits\n                chord: \"\",\n                lyric: newLyrics,\n            }),\n        ];\n    }\n\n    setChord(idable: IDable<\"ChordBlock\">, newChord: string): void {\n        const index = this.indexOf(idable.id);\n\n        this.elements[index].chord = newChord;\n\n        if (this.elements[index].chord === \"\") {\n            this.mergeBlocks(index);\n        }\n    }\n\n    // merge block at index with previous block\n    // merging lyrics and discarding chords\n    private mergeBlocks(index: number): void {\n        if (index === 0) {\n            return;\n        }\n\n        const prevBlock = this.elements[index - 1];\n        prevBlock.lyric += this.elements[index].lyric;\n        this.elements.splice(index, 1);\n    }\n\n    splitBlock(idable: IDable<\"ChordBlock\">, splitIndex: number): void {\n        const index = this.indexOf(idable.id);\n        const block = this.elements[index];\n        const newPrevBlock = block.split(splitIndex);\n        this.elements.splice(index, 0, newPrevBlock);\n    }\n\n    clone(): ChordLine {\n        const clone = new ChordLine(this.elements);\n        clone.id = this.id;\n        return clone;\n    }\n}\n\nconst SongMetadataValidator = iots.type({\n    title: iots.string,\n    composedBy: iots.string,\n    performedBy: iots.string,\n    asHeardFrom: iots.string,\n});\n\ntype SongMetadata = iots.TypeOf<typeof SongMetadataValidator>;\n\nconst ChordSongValidator = iots.type({\n    elements: iots.array(ChordLineValidator),\n    metadata: SongMetadataValidator,\n});\ntype ChordSongValidatedFields = iots.TypeOf<typeof ChordSongValidator>;\n\nexport class ChordSong extends Collection<ChordLine, \"ChordLine\"> {\n    metadata: SongMetadata;\n\n    constructor(elements?: ChordLine[], metadata?: SongMetadata) {\n        super(elements);\n\n        if (metadata !== undefined) {\n            this.metadata = metadata;\n        } else {\n            this.metadata = {\n                title: \"\",\n                composedBy: \"\",\n                performedBy: \"\",\n                asHeardFrom: \"\",\n            };\n        }\n    }\n\n    static fromValidatedFields(\n        validatedFields: ChordSongValidatedFields\n    ): ChordSong {\n        const chordLines: ChordLine[] = validatedFields.elements.map(\n            (chordLineValidatedFields: ChordLineValidatedFields) => {\n                return ChordLine.fromValidatedFields(chordLineValidatedFields);\n            }\n        );\n        return new ChordSong(chordLines, validatedFields.metadata);\n    }\n\n    serialize(): string {\n        return stringifyIgnoreID(this);\n    }\n\n    static deserialize(jsonStr: string): Either<Error, ChordSong> {\n        const result: Either<Error, unknown> = parseJSON(\n            jsonStr,\n            () => new Error(\"Failed to parse json string\")\n        );\n\n        if (isLeft(result)) {\n            return result;\n        }\n\n        const jsonObj = result.right;\n        const validationResult = ChordSongValidator.decode(jsonObj);\n\n        if (isLeft(validationResult)) {\n            return left(new Error(\"Invalid Chord Song object\"));\n        }\n\n        return right(this.fromValidatedFields(validationResult.right));\n    }\n\n    static fromLyricsLines(lyricLines: string[]): ChordSong {\n        const chordLines: ChordLine[] = lyricLines.map((lyricLine: string) =>\n            ChordLine.fromLyrics(lyricLine)\n        );\n        return new ChordSong(chordLines);\n    }\n\n    get chordLines(): ChordLine[] {\n        return this.elements;\n    }\n\n    get title(): string {\n        return this.metadata.title;\n    }\n\n    set title(newTitle: string) {\n        this.metadata.title = newTitle;\n    }\n\n    get performedBy(): string {\n        return this.metadata.performedBy;\n    }\n\n    set performedBy(newPerformedBy: string) {\n        this.metadata.performedBy = newPerformedBy;\n    }\n\n    get composedBy(): string {\n        return this.metadata.composedBy;\n    }\n\n    set composedBy(newComposedBy: string) {\n        this.metadata.composedBy = newComposedBy;\n    }\n\n    get asHeardFrom(): string {\n        return this.metadata.asHeardFrom;\n    }\n\n    set asHeardFrom(newAsHeardFrom: string) {\n        this.metadata.asHeardFrom = newAsHeardFrom;\n    }\n\n    clone(): ChordSong {\n        return new ChordSong(this.elements, this.metadata);\n    }\n}\n","import {\n    Theme,\n    useTheme,\n    FilledInput as UnstyledFilledInput,\n    InputBaseComponentProps,\n    TypographyVariant,\n} from \"@material-ui/core\";\nimport React, { useState } from \"react\";\nimport { withStyles } from \"@material-ui/styles\";\n\ninterface EditableLineProps {\n    children: string;\n    onFinish?: (newValue: string) => void;\n    onPasteOverflow?: (overflowContent: string[]) => void;\n    width?: string;\n    variant?: TypographyVariant;\n}\n\nconst EditableLine: React.FC<EditableLineProps> = (\n    props: EditableLineProps\n): JSX.Element => {\n    const [value, setValue] = useState<string>(props.children);\n    const inputRef: React.RefObject<HTMLInputElement> = React.createRef();\n    const theme = useTheme();\n\n    const updateValue = (\n        event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => {\n        setValue(event.target.value);\n    };\n\n    const forwardEnter = (\n        event: React.KeyboardEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => {\n        if (event.key === \"Enter\") {\n            finish(value);\n        }\n    };\n\n    const finish = (newValue: string) => {\n        if (props.onFinish) {\n            props.onFinish(newValue);\n        }\n    };\n\n    const blurHandler = () => {\n        finish(value);\n    };\n\n    const composeMultilinePaste = (\n        pasteContent: string[]\n    ): [string, string[]] => {\n        let beforeSelectionStr: string;\n        let afterSelectionStr: string;\n        if (\n            inputRef.current === null ||\n            inputRef.current.selectionStart === null ||\n            inputRef.current.selectionEnd === null\n        ) {\n            beforeSelectionStr = value;\n            afterSelectionStr = \"\";\n        } else {\n            beforeSelectionStr = value.slice(\n                0,\n                inputRef.current.selectionStart\n            );\n            afterSelectionStr = value.slice(inputRef.current.selectionEnd);\n        }\n\n        const newValue = beforeSelectionStr + pasteContent[0];\n\n        const newPasteLines = pasteContent.slice(1);\n        const lastIndex = newPasteLines.length - 1;\n        newPasteLines[lastIndex] += afterSelectionStr;\n\n        return [newValue, newPasteLines];\n    };\n\n    const pasteHandler = (event: React.ClipboardEvent<HTMLDivElement>) => {\n        const payload = event.clipboardData.getData(\"text/plain\");\n\n        if (payload === \"\") {\n            return;\n        }\n\n        const linesOfText: string[] = payload.split(\"\\n\");\n\n        if (linesOfText.length > 1 && props.onPasteOverflow !== undefined) {\n            event.preventDefault();\n\n            const [newValue, newPasteLines] = composeMultilinePaste(\n                linesOfText\n            );\n\n            setValue(newValue);\n            finish(newValue);\n            props.onPasteOverflow(newPasteLines);\n        }\n    };\n\n    const browserInputProps = (theme: Theme, width?: string) => {\n        let padding: string | number | undefined = 0;\n        if (\n            props.variant !== undefined &&\n            theme?.typography?.[props.variant]?.padding\n        ) {\n            padding = theme.typography[props.variant].padding;\n        }\n\n        const inputProps: InputBaseComponentProps = {\n            style: {\n                padding: padding,\n            },\n        };\n\n        if (width && inputProps.style) {\n            inputProps.style.width = width;\n        }\n\n        return inputProps;\n    };\n\n    const FilledInput = withStyles((theme: Theme) => {\n        if (props.variant === undefined) {\n            return { root: {} };\n        }\n\n        return {\n            root: {\n                fontSize: theme.typography[props.variant].fontSize,\n            },\n        };\n    })(UnstyledFilledInput);\n\n    return (\n        <FilledInput\n            autoFocus\n            inputProps={{\n                \"data-testid\": \"InnerInput\",\n                ...browserInputProps(theme, props.width),\n            }}\n            inputRef={inputRef}\n            value={value}\n            onBlur={blurHandler}\n            onChange={updateValue}\n            onKeyDown={forwardEnter}\n            onPaste={pasteHandler}\n            fullWidth\n            data-testid=\"EditableLine\"\n        />\n    );\n};\n\nexport default EditableLine;\n","export const isWhitespace = (s: string): boolean => {\n    return /^\\s+$/.test(s);\n};\n\nexport const inflatingWhitespace = (): string => {\n    return \"\\u00A0\";\n};\n\nexport const inflateIfEmpty = (value: string) => {\n    if (isWhitespace(value)) {\n        return inflatingWhitespace();\n    }\n\n    return value;\n};\n","import React from \"react\";\nimport { Typography, Theme } from \"@material-ui/core\";\nimport { inflateIfEmpty } from \"../common/Whitespace\";\nimport { withStyles } from \"@material-ui/styles\";\n\nconst ChordTypography = withStyles((theme: Theme) => ({\n    root: {\n        whiteSpace: \"pre\",\n        \"&:hover\": {\n            color: theme.palette.secondary.main,\n        },\n        cursor: \"pointer\",\n        fontFamily: \"PoriChord\",\n    },\n}))(Typography);\n\ninterface ChordSymbolProps {\n    children: string;\n}\n\nconst ChordSymbol: React.FC<ChordSymbolProps> = (\n    props: ChordSymbolProps\n): JSX.Element => {\n    const formattedChord = (): string => {\n        let chord = props.children;\n        if (chord.endsWith(\" \")) {\n            return chord;\n        }\n\n        chord = chord + \" \";\n\n        return inflateIfEmpty(chord);\n    };\n\n    return (\n        <ChordTypography variant=\"h5\" display=\"inline\" data-testid=\"Chord\">\n            {formattedChord()}\n        </ChordTypography>\n    );\n};\n\nexport default ChordSymbol;\n","import { Typography, withStyles, Theme, Grid, Box } from \"@material-ui/core\";\nimport React, { useState } from \"react\";\n\nimport { DataTestID } from \"../common/DataTestID\";\nimport { isWhitespace, inflatingWhitespace } from \"../common/Whitespace\";\nimport { ChordBlock } from \"../common/ChordModel\";\nimport ChordSymbol from \"./ChordSymbol\";\nimport { IDable } from \"../common/Collection\";\nimport EditableLine from \"./EditableLine\";\n\ninterface BlockProps extends DataTestID {\n    chordBlock: ChordBlock;\n    onChordChange?: (id: IDable<\"ChordBlock\">, newChord: string) => void;\n    onBlockSplit?: (id: IDable<\"ChordBlock\">, splitIndex: number) => void;\n}\n\nconst WordTarget = withStyles((theme: Theme) => ({\n    root: {\n        \"&:hover\": {\n            color: theme.palette.secondary.main,\n        },\n        cursor: \"pointer\",\n    },\n}))(Typography);\n\nconst SpaceTarget = withStyles((theme: Theme) => ({\n    root: {\n        whiteSpace: \"pre\",\n        \"&:hover\": {\n            backgroundColor: theme.palette.secondary.light,\n        },\n        cursor: \"pointer\",\n    },\n}))(Typography);\n\nconst Block: React.FC<BlockProps> = (props: BlockProps): JSX.Element => {\n    const [editing, setEditing] = useState(false);\n\n    let lyricTokens: string[] = props.chordBlock.lyricTokens;\n\n    if (lyricTokens.length === 0) {\n        lyricTokens = [inflatingWhitespace()];\n    }\n\n    const clickHandler = (tokenIndex: number): (() => void) => {\n        return () => {\n            // block splitting happens after the first token\n            // as first token is already aligned with the current chord\n            if (tokenIndex !== 0 && props.onBlockSplit) {\n                props.onBlockSplit(props.chordBlock, tokenIndex);\n            }\n\n            setEditing(true);\n        };\n    };\n\n    const lyricBlock = (lyric: string, index: number): React.ReactElement => {\n        const typographyProps = {\n            key: index,\n            variant: \"h5\" as \"h5\",\n            display: \"inline\" as \"inline\",\n            onClick: clickHandler(index),\n            \"data-testid\": `Token-${index}`,\n        };\n\n        if (isWhitespace(lyric)) {\n            return <SpaceTarget {...typographyProps}>{lyric}</SpaceTarget>;\n        } else {\n            return <WordTarget {...typographyProps}>{lyric}</WordTarget>;\n        }\n    };\n\n    const lyricBlocks = lyricTokens.map((lyricToken: string, index: number) =>\n        lyricBlock(lyricToken, index)\n    );\n\n    const endEdit = (newChord: string) => {\n        if (props.onChordChange) {\n            props.onChordChange(props.chordBlock, newChord);\n        }\n\n        setEditing(false);\n    };\n\n    let chordRow: React.ReactElement;\n    if (!editing) {\n        chordRow = <ChordSymbol>{props.chordBlock.chord}</ChordSymbol>;\n    } else {\n        chordRow = (\n            <Box data-testid=\"ChordEdit\">\n                <EditableLine width=\"5em\" variant=\"h5\" onFinish={endEdit}>\n                    {props.chordBlock.chord}\n                </EditableLine>\n            </Box>\n        );\n    }\n\n    return (\n        <Grid\n            container\n            direction=\"column\"\n            component=\"span\"\n            data-testid={props[\"data-testid\"]}\n        >\n            <Grid item onClick={() => setEditing(true)}>\n                {chordRow}\n            </Grid>\n            <Grid item data-testid=\"Lyric\">\n                <>{lyricBlocks}</>\n            </Grid>\n        </Grid>\n    );\n};\n\nexport default Block;\n","import {\n    Box,\n    withStyles,\n    Grid,\n    ButtonGroup,\n    Theme,\n    Button as UnstyledButton,\n    Tooltip as UnstyledTooltip,\n} from \"@material-ui/core\";\nimport React from \"react\";\n\nimport grey from \"@material-ui/core/colors/grey\";\n\nimport { ChordBlock, ChordLine } from \"../common/ChordModel\";\nimport Block from \"./Block\";\n\nimport UnstyledEditIcon from \"@material-ui/icons/Edit\";\nimport UnstyledAddIcon from \"@material-ui/icons/Add\";\nimport UnstyledRemoveIcon from \"@material-ui/icons/Remove\";\nimport { IDable } from \"../common/Collection\";\n\nconst iconColorStyle = {\n    root: {\n        color: \"white\",\n    },\n};\n\nconst EditIcon = withStyles(iconColorStyle)(UnstyledEditIcon);\nconst AddIcon = withStyles(iconColorStyle)(UnstyledAddIcon);\nconst RemoveIcon = withStyles(iconColorStyle)(UnstyledRemoveIcon);\n\nconst Button = withStyles((theme: Theme) => ({\n    contained: {\n        backgroundColor: theme.palette.primary.main,\n        \"&:hover\": {\n            backgroundColor: theme.palette.primary.dark,\n        },\n    },\n}))(UnstyledButton);\n\nconst Tooltip = withStyles({\n    tooltip: {\n        padding: 0,\n    },\n})(UnstyledTooltip);\n\nconst HighlightableBox = withStyles((theme: Theme) => ({\n    root: {\n        \"&:hover\": {\n            backgroundColor: grey[100],\n        },\n        maxWidth: theme.spacing(92),\n    },\n}))(Box);\n\ninterface NonEditableLineProps {\n    chordLine: ChordLine;\n    onEditButton?: (\n        event: React.MouseEvent<HTMLButtonElement, MouseEvent>\n    ) => void;\n    onAddButton?: (\n        event: React.MouseEvent<HTMLButtonElement, MouseEvent>\n    ) => void;\n    onRemoveButton?: (\n        event: React.MouseEvent<HTMLButtonElement, MouseEvent>\n    ) => void;\n    onChangeLine?: (id: IDable<\"ChordLine\">) => void;\n}\n\nconst NonEditableLine: React.FC<NonEditableLineProps> = (\n    props: NonEditableLineProps\n): JSX.Element => {\n    let chordBlocks: ChordBlock[] = props.chordLine.chordBlocks;\n    if (chordBlocks.length === 0) {\n        chordBlocks = [\n            new ChordBlock({\n                chord: \"\",\n                lyric: \"\",\n            }),\n        ];\n    }\n\n    const hoverMenu = (): React.ReactElement => {\n        return (\n            <ButtonGroup variant=\"outlined\" orientation=\"vertical\">\n                <Button\n                    variant=\"contained\"\n                    onClick={props.onEditButton}\n                    data-testid={\"EditButton\"}\n                >\n                    <EditIcon />\n                </Button>\n                <Button\n                    variant=\"contained\"\n                    onClick={props.onAddButton}\n                    data-testid={\"AddButton\"}\n                >\n                    <AddIcon />\n                </Button>\n                <Button\n                    variant=\"contained\"\n                    onClick={props.onRemoveButton}\n                    data-testid={\"RemoveButton\"}\n                >\n                    <RemoveIcon />\n                </Button>\n            </ButtonGroup>\n        );\n    };\n\n    const chordChangeHandler = (id: IDable<\"ChordBlock\">, newChord: string) => {\n        props.chordLine.setChord(id, newChord);\n\n        if (props.onChangeLine) {\n            props.onChangeLine(props.chordLine);\n        }\n    };\n\n    const blockSplitHandler = (\n        id: IDable<\"ChordBlock\">,\n        splitIndex: number\n    ) => {\n        props.chordLine.splitBlock(id, splitIndex);\n\n        if (props.onChangeLine) {\n            props.onChangeLine(props.chordLine);\n        }\n    };\n\n    const blocks: React.ReactElement[] = chordBlocks.map(\n        (chordBlock: ChordBlock, index: number) => (\n            <Grid item key={chordBlock.id}>\n                <Block\n                    key={chordBlock.id}\n                    chordBlock={chordBlock}\n                    onChordChange={chordChangeHandler}\n                    onBlockSplit={blockSplitHandler}\n                    data-testid={`Block-${index}`}\n                ></Block>\n            </Grid>\n        )\n    );\n\n    return (\n        <Tooltip placement=\"right\" title={hoverMenu()} interactive>\n            <HighlightableBox data-testid={\"NoneditableLine\"}>\n                <Grid container>{blocks}</Grid>\n            </HighlightableBox>\n        </Tooltip>\n    );\n};\n\nexport default NonEditableLine;\n","import { Box, Typography, Slide, Grid } from \"@material-ui/core\";\nimport React, { useState } from \"react\";\nimport EditableLine from \"./EditableLine\";\n\nimport { DataTestID } from \"../common/DataTestID\";\nimport { ChordLine } from \"../common/ChordModel\";\nimport { IDable } from \"../common/Collection\";\nimport NonEditableLine from \"./NonEditableLine\";\n\ninterface LineProps extends DataTestID {\n    chordLine: ChordLine;\n    onChangeLine?: (id: IDable<\"ChordLine\">) => void;\n    onAddLine?: (id: IDable<\"ChordLine\">) => void;\n    onRemoveLine?: (id: IDable<\"ChordLine\">) => void;\n    onPasteOverflow?: (\n        id: IDable<\"ChordLine\">,\n        overflowPasteContent: string[]\n    ) => void;\n}\n\nconst Line: React.FC<LineProps> = (props: LineProps): JSX.Element => {\n    const [editing, setEditing] = useState(false);\n    const [removed, setRemoved] = useState(false);\n\n    const startEdit = () => {\n        setEditing(true);\n    };\n\n    const finishEdit = (newLyrics: string) => {\n        setEditing(false);\n\n        props.chordLine.replaceLyrics(newLyrics);\n\n        if (props.onChangeLine) {\n            props.onChangeLine(props.chordLine);\n        }\n    };\n\n    const addHandler = () => {\n        if (props.onAddLine) {\n            props.onAddLine(props.chordLine);\n        }\n    };\n\n    const removalTime = 250;\n\n    const removeHandler = () => {\n        setRemoved(true);\n\n        if (props.onRemoveLine) {\n            setTimeout(() => {\n                if (props.onRemoveLine) {\n                    props.onRemoveLine(props.chordLine);\n                }\n            }, removalTime);\n        }\n    };\n\n    const pasteOverflowHandler = (overflowContent: string[]) => {\n        if (props.onPasteOverflow) {\n            props.onPasteOverflow(props.chordLine, overflowContent);\n            setEditing(false);\n        }\n    };\n\n    const nonEditableLine = (): React.ReactElement => {\n        return (\n            <NonEditableLine\n                chordLine={props.chordLine}\n                onChangeLine={props.onChangeLine}\n                onAddButton={addHandler}\n                onRemoveButton={removeHandler}\n                onEditButton={startEdit}\n            />\n        );\n    };\n\n    const editableLine = (): React.ReactElement => {\n        const lyrics = props.chordLine.lyrics;\n\n        return (\n            <Grid container direction=\"column\">\n                <Grid item>\n                    <Typography variant=\"h5\">Chords Placeholder</Typography>\n                </Grid>\n                <Grid item>\n                    <EditableLine\n                        variant=\"h5\"\n                        onFinish={finishEdit}\n                        onPasteOverflow={pasteOverflowHandler}\n                    >\n                        {lyrics}\n                    </EditableLine>\n                </Grid>\n            </Grid>\n        );\n    };\n\n    const elem: React.ReactElement = editing\n        ? editableLine()\n        : nonEditableLine();\n    const yeetDirection = removed ? \"up\" : \"down\";\n\n    return (\n        <Slide direction={yeetDirection} in={!removed} timeout={removalTime}>\n            <Box\n                borderBottom={1}\n                borderColor=\"grey.50\"\n                width=\"auto\"\n                minWidth=\"30em\"\n                margin=\"3rem\"\n                data-testid={props[\"data-testid\"]}\n            >\n                {elem}\n            </Box>\n        </Slide>\n    );\n};\n\nexport default Line;\n","import React from \"react\";\nimport {\n    Paper as UnstyledPaper,\n    Theme,\n    withStyles,\n    Grid,\n} from \"@material-ui/core\";\nimport Line from \"./Line\";\nimport { ChordLine, ChordSong } from \"../common/ChordModel\";\nimport { IDable } from \"../common/Collection\";\n\nconst Paper = withStyles((theme: Theme) => ({\n    root: {\n        padding: theme.spacing(9.5),\n        width: \"max-content\",\n    },\n}))(UnstyledPaper);\n\ninterface ChordPaperBodyProps {\n    song: ChordSong;\n    onSongChanged?: (updatedSong: ChordSong) => void;\n}\n\nconst ChordPaperBody: React.FC<ChordPaperBodyProps> = (\n    props: ChordPaperBodyProps\n): React.ReactElement => {\n    const addLine = (id: IDable<\"ChordLine\">) => {\n        const newLine: ChordLine = new ChordLine();\n        props.song.addAfter(id, newLine);\n        notifySongChanged();\n    };\n\n    const removeLine = (id: IDable<\"ChordLine\">) => {\n        props.song.remove(id);\n        notifySongChanged();\n    };\n\n    const changeLine = (id: IDable<\"ChordLine\">) => {\n        notifySongChanged();\n    };\n\n    const pasteOverflowFromLine = (\n        id: IDable<\"ChordLine\">,\n        overflowContent: string[]\n    ) => {\n        const newChordLines = overflowContent.map((newLyricLine: string) =>\n            ChordLine.fromLyrics(newLyricLine)\n        );\n        props.song.addAfter(id, ...newChordLines);\n        notifySongChanged();\n    };\n\n    const notifySongChanged = () => {\n        if (props.onSongChanged) {\n            props.onSongChanged(props.song);\n        }\n    };\n\n    return (\n        <Paper elevation={0}>\n            <Grid container justify=\"center\">\n                <Grid item>\n                    {props.song.chordLines.map(\n                        (line: ChordLine, index: number) => {\n                            return (\n                                <Line\n                                    key={line.id}\n                                    chordLine={line}\n                                    onAddLine={addLine}\n                                    onRemoveLine={removeLine}\n                                    onChangeLine={changeLine}\n                                    onPasteOverflow={pasteOverflowFromLine}\n                                    data-testid={`Line-${index}`}\n                                />\n                            );\n                        }\n                    )}\n                </Grid>\n            </Grid>\n        </Paper>\n    );\n};\n\nexport default ChordPaperBody;\n","import { Box, Typography, TypographyProps, Theme } from \"@material-ui/core\";\nimport React, { useState } from \"react\";\nimport EditableLine from \"./EditableLine\";\n\nimport { DataTestID } from \"../common/DataTestID\";\nimport { inflateIfEmpty } from \"../common/Whitespace\";\nimport { withStyles } from \"@material-ui/styles\";\n\nimport grey from \"@material-ui/core/colors/grey\";\n\ninterface EditableTypographyProps extends DataTestID, TypographyProps {\n    children: string;\n    onValueChange?: (newValue: string) => void;\n    placeholder?: string;\n}\n\nconst PlaceholderTypography = withStyles((theme: Theme) => ({\n    root: {\n        color: grey[200],\n    },\n}))(Typography);\n\nconst EditableTypography: React.FC<EditableTypographyProps> = (\n    props: EditableTypographyProps\n): JSX.Element => {\n    const [editing, setEditing] = useState(false);\n\n    const startEdit = () => {\n        setEditing(true);\n    };\n\n    const finishEdit = (newValue: string) => {\n        setEditing(false);\n        if (props.onValueChange) {\n            props.onValueChange(newValue);\n        }\n    };\n\n    const nonEditableLine = (): React.ReactElement => {\n        const {\n            children,\n            placeholder,\n            onValueChange,\n            ...typographyProps\n        } = props;\n\n        if (props.children === \"\" && props.placeholder !== undefined) {\n            return (\n                <PlaceholderTypography {...typographyProps} onClick={startEdit}>\n                    {props.placeholder}\n                </PlaceholderTypography>\n            );\n        }\n\n        return (\n            <Typography {...typographyProps} onClick={startEdit}>\n                {inflateIfEmpty(props.children)}\n            </Typography>\n        );\n    };\n\n    const editableLine = (): React.ReactElement => {\n        if (props.variant === \"inherit\" || props.variant === \"srOnly\") {\n            throw new Error(\"can't have these variant types\");\n        }\n\n        return (\n            <EditableLine\n                variant={props.variant}\n                onFinish={finishEdit}\n                data-testid={\"EditableLine\"}\n            >\n                {props.children}\n            </EditableLine>\n        );\n    };\n\n    const elem: React.ReactElement = editing\n        ? editableLine()\n        : nonEditableLine();\n\n    return <Box>{elem}</Box>;\n};\n\nexport default EditableTypography;\n","import React from \"react\";\nimport { Typography, Theme, Grid, Box } from \"@material-ui/core\";\nimport { useTheme } from \"@material-ui/styles\";\nimport EditableTypography from \"./EditableTypography\";\nimport { ChordSong } from \"../common/ChordModel\";\n\ninterface HeaderProps {\n    song: ChordSong;\n    onSongChanged?: (updatedSong: ChordSong) => void;\n}\n\nconst Header: React.FC<HeaderProps> = (props: HeaderProps): JSX.Element => {\n    const theme: Theme = useTheme();\n\n    const notifySongChanged = (): void => {\n        if (props.onSongChanged) {\n            props.onSongChanged(props.song);\n        }\n    };\n\n    const updateTitleHandler = (newTitle: string) => {\n        props.song.title = newTitle;\n        notifySongChanged();\n    };\n\n    const updateComposeHandler = (newComposer: string) => {\n        props.song.composedBy = newComposer;\n        notifySongChanged();\n    };\n\n    const updatePerformerHandler = (newPerformer: string) => {\n        props.song.performedBy = newPerformer;\n        notifySongChanged();\n    };\n\n    const updateHeardFrom = (newHeardFrom: string) => {\n        props.song.asHeardFrom = newHeardFrom;\n        notifySongChanged();\n    };\n\n    const leftHeader = (\n        <Grid item container xs={3} direction=\"column\">\n            <Grid item>\n                <Typography display=\"inline\" variant=\"caption\">\n                    As heard from:{\" \"}\n                </Typography>\n                <EditableTypography\n                    variant=\"caption\"\n                    placeholder=\"https://www.youtube.com/watch?v=dM9zwZCOmjM\"\n                    onValueChange={updateHeardFrom}\n                    data-testid=\"AsHeardAt\"\n                >\n                    {props.song.asHeardFrom}\n                </EditableTypography>\n            </Grid>\n        </Grid>\n    );\n\n    const midHeader = (\n        <Grid item xs={6}>\n            <EditableTypography\n                variant=\"h4\"\n                align=\"center\"\n                data-testid=\"SongTitle\"\n                placeholder=\"Song Title\"\n                onValueChange={updateTitleHandler}\n            >\n                {props.song.title}\n            </EditableTypography>\n        </Grid>\n    );\n\n    const rightHeader = (\n        <Grid item container xs={3} direction=\"column\">\n            <Grid item>\n                <Typography display=\"inline\" variant=\"subtitle2\">\n                    Composed by:{\" \"}\n                </Typography>\n\n                <EditableTypography\n                    variant=\"subtitle2\"\n                    placeholder=\"Stock Waterman\"\n                    onValueChange={updateComposeHandler}\n                    data-testid=\"ComposedBy\"\n                >\n                    {props.song.composedBy}\n                </EditableTypography>\n            </Grid>\n            <Grid item>\n                <Typography display=\"inline\" variant=\"subtitle2\">\n                    Performed by:{\" \"}\n                </Typography>\n\n                <EditableTypography\n                    variant=\"subtitle2\"\n                    placeholder=\"Rick Astley\"\n                    onValueChange={updatePerformerHandler}\n                    data-testid=\"PerformedBy\"\n                >\n                    {props.song.performedBy}\n                </EditableTypography>\n            </Grid>\n        </Grid>\n    );\n\n    return (\n        <Box\n            paddingTop={theme.spacing(1)}\n            paddingLeft={theme.spacing(0.5)}\n            paddingRight={theme.spacing(0.5)}\n            data-testid=\"Header\"\n        >\n            <Grid container>\n                {leftHeader}\n                {midHeader}\n                {rightHeader}\n            </Grid>\n        </Box>\n    );\n};\n\nexport default Header;\n","import {\n    SpeedDial as UnstyledSpeedDial,\n    SpeedDialAction,\n    SpeedDialIcon,\n} from \"@material-ui/lab\";\nimport { withStyles } from \"@material-ui/styles\";\nimport { Theme } from \"@material-ui/core\";\nimport SaveIcon from \"@material-ui/icons/Save\";\nimport FolderOpenIcon from \"@material-ui/icons/FolderOpen\";\nimport React, { useState } from \"react\";\nimport { ChordSong } from \"../common/ChordModel\";\nimport { isLeft } from \"fp-ts/lib/Either\";\nimport { useSnackbar } from \"notistack\";\n\ninterface ChordPaperMenuProps {\n    song: ChordSong;\n    onLoad?: (loadedSong: ChordSong) => void;\n}\n\nconst SpeedDial = withStyles((theme: Theme) => ({\n    root: {\n        position: \"fixed\",\n        bottom: theme.spacing(2),\n        right: theme.spacing(2),\n    },\n}))(UnstyledSpeedDial);\n\nconst ChordPaperMenu: React.FC<ChordPaperMenuProps> = (\n    props: ChordPaperMenuProps\n): JSX.Element => {\n    const [open, setOpen] = useState(false);\n    const { enqueueSnackbar } = useSnackbar();\n\n    const openMenu = () => {\n        setOpen(true);\n    };\n\n    const closeMenu = () => {\n        setOpen(false);\n    };\n\n    const saveAction = () => {\n        const blob = new Blob([props.song.serialize()], {\n            type: \"application/json\",\n        });\n        const objectURL = URL.createObjectURL(blob);\n\n        const anchor = document.createElement(\"a\");\n        anchor.download = \"chord_paper_song.json\";\n        anchor.href = objectURL;\n        anchor.click();\n\n        URL.revokeObjectURL(objectURL);\n    };\n\n    const loadAction = async () => {\n        const inputElem: HTMLInputElement = document.createElement(\"input\");\n        inputElem.type = \"file\";\n        inputElem.addEventListener(\"change\", () => {\n            const fileList = inputElem.files;\n            if (fileList === null) {\n                return;\n            }\n\n            if (fileList.length > 1) {\n                enqueueSnackbar(\n                    \"Multiple files selected, only one file expected\",\n                    { variant: \"error\" }\n                );\n                return;\n            }\n\n            const file = fileList.item(0);\n            if (file === null) {\n                enqueueSnackbar(\"Could not retrieve file from file dialog\", {\n                    variant: \"error\",\n                });\n                return;\n            }\n\n            const fileReader = new FileReader();\n            fileReader.onload = (ev: ProgressEvent<FileReader>) => {\n                if (\n                    ev.target === null ||\n                    ev.target.result === null ||\n                    ev.target.result instanceof ArrayBuffer\n                ) {\n                    return;\n                }\n\n                const results = ChordSong.deserialize(ev.target.result);\n                if (isLeft(results)) {\n                    enqueueSnackbar(\n                        \"Can't load file, Song file failed validation\",\n                        {\n                            variant: \"error\",\n                        }\n                    );\n                    return;\n                }\n\n                if (props.onLoad) {\n                    props.onLoad(results.right);\n                }\n            };\n\n            fileReader.readAsText(file);\n        });\n\n        inputElem.click();\n    };\n\n    return (\n        <SpeedDial\n            icon={<SpeedDialIcon />}\n            open={open}\n            onOpen={openMenu}\n            onClose={closeMenu}\n            ariaLabel=\"SpeedDial\"\n        >\n            <SpeedDialAction\n                icon={<SaveIcon />}\n                tooltipTitle=\"Save\"\n                onClick={saveAction}\n            ></SpeedDialAction>\n            <SpeedDialAction\n                icon={<FolderOpenIcon />}\n                tooltipTitle=\"Load\"\n                onClick={loadAction}\n            ></SpeedDialAction>\n        </SpeedDial>\n    );\n};\n\nexport default ChordPaperMenu;\n","import React, { useState } from \"react\";\nimport { Paper, Theme, withStyles } from \"@material-ui/core\";\nimport ChordPaperBody from \"./ChordPaperBody\";\nimport Header from \"./Header\";\nimport { ChordSong } from \"../common/ChordModel\";\nimport ChordPaperMenu from \"./ChordPaperMenu\";\n\nconst RootPaper = withStyles((theme: Theme) => ({\n    root: {\n        margin: theme.spacing(5),\n        minHeight: \"750px\",\n        width: \"max-content\",\n    },\n}))(Paper);\n\ninterface ChordPaperProps {\n    initialSong: ChordSong;\n}\n\nconst ChordPaper: React.FC<ChordPaperProps> = (\n    props: ChordPaperProps\n): JSX.Element => {\n    const [song, setSong] = useState<ChordSong>(props.initialSong);\n\n    const songChangeHandler = (updatedSong: ChordSong) => {\n        setSong(updatedSong.clone());\n    };\n\n    const loadHandler = (loadedSong: ChordSong) => {\n        setSong(loadedSong.clone());\n    };\n\n    return (\n        <RootPaper elevation={3}>\n            <Header\n                data-testid={\"Header\"}\n                song={song}\n                onSongChanged={songChangeHandler}\n            />\n            <ChordPaperBody song={song} onSongChanged={songChangeHandler} />\n            <ChordPaperMenu song={song} onLoad={loadHandler} />\n        </RootPaper>\n    );\n};\n\nexport default ChordPaper;\n","import React from \"react\";\nimport {\n    Theme,\n    ThemeProvider,\n    createMuiTheme,\n    PaletteColorOptions,\n    Grid,\n} from \"@material-ui/core\";\nimport { tokenize } from \"./common/LyricTokenizer\";\nimport { ChordSong, ChordLine, ChordBlock } from \"./common/ChordModel\";\nimport ChordPaper from \"./components/ChordPaper\";\nimport { SnackbarProvider } from \"notistack\";\n\nconst createTheme = (): Theme => {\n    const lightBlue: PaletteColorOptions = {\n        main: \"#4fc3f7\",\n        light: \"#8bf6ff\",\n        dark: \"#0093c4\",\n        contrastText: \"#000000\",\n    };\n\n    const purple: PaletteColorOptions = {\n        main: \"#844ffc\",\n        light: \"#bb7eff\",\n        dark: \"#4a1fc8\",\n        contrastText: \"#ffffff\",\n    };\n\n    return createMuiTheme({\n        palette: {\n            primary: lightBlue,\n            secondary: purple,\n        },\n        typography: {\n            fontFamily: \"Playfair\",\n            fontWeightRegular: 500,\n        },\n    });\n};\n\nfunction App() {\n    const theme: Theme = createTheme();\n\n    const lyrics = [\n        \"We're no strangers to love\",\n        \"You know the rules and so do I\",\n        \"A full commitment's what I'm thinking of\",\n        \"You wouldn't get this from any other guy\",\n        \"I just wanna tell you how I'm feeling\",\n        \"Gotta make you understand\",\n        \"Never gonna give you up\",\n        \"Never gonna let you down\",\n        \"Never gonna run around and desert you\",\n        \"Never gonna make you cry\",\n        \"Never gonna say goodbye\",\n        \"Never gonna tell a lie and hurt you\",\n    ];\n\n    const chords = [\"A\", \"Bb7\", \"Cm\", \"D/C#\", \"Em7\", \"Fmaj7\", \"G\"];\n\n    const randomChord = (): string => {\n        return chords[Math.floor(Math.random() * chords.length)];\n    };\n\n    const chunk = (arr: string, tokenSize: number): string[] => {\n        const tokens = tokenize(arr);\n        const results: string[] = [];\n\n        for (let i = 0; i < tokens.length; i += tokenSize) {\n            const subArr = tokens.slice(i, i + tokenSize);\n            results.push(subArr.join(\"\"));\n        }\n\n        return results;\n    };\n\n    const assembleSong = (): ChordSong => {\n        const chordLines: ChordLine[] = lyrics.map((lyricLine: string) =>\n            assembleLine(lyricLine)\n        );\n\n        return new ChordSong(chordLines);\n    };\n\n    const assembleLine = (lyrics: string): ChordLine => {\n        const lyricChunks = chunk(lyrics, 4);\n\n        const chordBlocks: ChordBlock[] = lyricChunks.map(\n            (lyricChunk: string) => {\n                return new ChordBlock({\n                    chord: randomChord(),\n                    lyric: lyricChunk,\n                });\n            }\n        );\n\n        return new ChordLine(chordBlocks);\n    };\n\n    return (\n        <ThemeProvider theme={theme}>\n            <SnackbarProvider>\n                <Grid container justify=\"center\">\n                    <Grid item>\n                        <ChordPaper initialSong={assembleSong()} />\n                    </Grid>\n                </Grid>\n            </SnackbarProvider>\n        </ThemeProvider>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}